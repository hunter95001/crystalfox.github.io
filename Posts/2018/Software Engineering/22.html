<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UML &객체지향   </title>
  <link rel="stylesheet" type="text/css" href="../../../CSS/Style.css">
  <link rel="stylesheet" type="text/css" href="../../../CSS/Post.css">
	   <link rel="stylesheet" type="text/css" href="../../../CSS/Attach.css">
   <link rel="shortcut icon" href="https://raw.githubusercontent.com/hunter95001/crystalfox.github.io/master/Image/favicon.ico">
	
  <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $("#sider").load("https://hunter95001.github.io/crystalfox.github.io/include/sider.html"); // 원하는 파일 경로를 삽입하면 된다
      $("#footers").load("https://hunter95001.github.io/crystalfox.github.io/include/footer.html"); // 추가 인클루드를 원할 경우 이런식으로 추가하면 된다
    });
  </script>
<style>
<style>  
table { border-collapse:collapse; }  
th, td { border:1px solid black; }
</style>
</head>

<body>
  <div id="wrapper">

    <div id="sider"></div>

    <div id="main-wrapper">
      <div style="maring:30px">
        <font size="5" color="#f0f0f0">Div 영역입니다.</font>
      </div>
      <div class="main-post">


        <div class="main-title">
           <h1>UML & 객체지향  </h1>
          <h2>Software Engineering</h2>
          <p class="main-title-time">작성일 : 2019-08-01</p>
        </div>
        <hr>
 <!--  본문 시작-->
   
	      <h1><p style="text-align: center">UML</p></h1>

	      <font style="font-weight:bold;">※ UML = 객체지향 소프트웨어를 모델링 하는 표준 그래픽 언어.</font><br>

<h2><p style="text-align: center">UML 다이어그램 종류</p></h2>
<h3>Use Case [사용 사례] 다이어그램 <h3>
-액터와 Use Case[사용 사례]를 통해 시스템의 기능을 모델링 하는데 사용<br>
<br>
<h3>클래스 다이어그램 </h3>
-클래스 이름, 속성, 오퍼레이션 등 시스템의 정적인 구조를 나타냄.<br>
<br>
<h3>시퀀스 다이어그램 </h3>
-객체 사이의 메시지 교환을 시간의 흐름에 따라 나타낸 것이다.<br>
<br>
<h3>상태 다이어그램</h3>
 -외부 자극에 대한 시스템의 동적 상태 변화를 나타낸다.<br>
<br>
<h3>UML의 특징</h3>
비주얼화<br>
명세<br>
구축<br>
문서화<br>
테스트기준<br>
<br>
사용자가 무엇을 원하는지 파악하기 위해서.<br>
<br>
사용자관점을 이해해야 유용한 시스템을 만들 수 있다. (What)<br>
개발자 관점 (How)<br>
<br>
유스케이스의 역할 : 사용자의 관점에서 시스템을 모델링<br>
액터: 이벤트 흐름을 시작하는 객체<br>
포함[include] 관계 : 유스케이스를 수행할 때 다른 유스케이스가 드시 수행되는 것 [필수, 공통]<br>
확장[extend] 관계 : 상위 유스케이스로부터 어떠한 특정 조건에 의해 수행됨. [선택]<br>
일반화 관계<br>
<br>
<h3>모델링 절차</h3>
1. 시스템 상황을 확인<br>
2. 액터 식별<br>
3. 유스케이스 식별<br>
4. 유스케이스 다이어그램 작성<br>
5. 유스케이스 명세서 작성<br>
6. 유스케이스 실체화.<br>
<br>
<h3>UML</h3>
객체지향 모델링 언어<br>
-요구분석이나 설계<br>
<br>
소프트웨어 개발 단계<br>
요구분석 -설계 -코딩 -테스트 -유지보수<br>
<br>
1.요구분석<br>
-사용자가 요구하는것을 분석합니다 <br>
- 유스케이스 다이어그램으로 표현합니다.<br>
<br>
2.설계<br>
-클래스 다이어 그램.<br>
-ER 다이어 그램 [데이터베이스 설계]<br>
-순차 다이어그램 [통신이 얻허게 되는지 알아봄.]<br>
-커뮤니케이션 다이어그램 [전체를 한번에 볼수 있음]<br>
<br>
3.코딩<br>
-코딩을 어떻게 할건지. [정검표에 맞춰서]<br>
<br>
4.테스트<br>
-테스트 케이스 만듬. <br>
ex)아이디 중복 체크, 비밀번호 확인 등<br>
<br>
5.유지보수<br>
-기능의 개선<br>
-형상관리<br>
	
	 <h1><p style="text-align: center">객체지향</p></h1>
<h3>객체 지향 프로그램 </h3>
-프러시저 추상화+데이터 추상화<br>
<br><br>
<h3>프러시저(함수) 추상화</h3>
-특정 프러시저를 사용할 자세히 모르더라도 어떻게 호출하고 무엇을 수행하는지 자세한 것은 걱정할 필요가 없다.<br>
<br>
<h3>데이터 추상화 </h3>
-데이터에 대한 조작, 오퍼레이션도 함께 정의함<br>
<br>
<h3>객체지향 패러다임</h3>
-데이터 및 데이터에 접근하고 수정하는 프러시저를 같은 범주 안에 두고 캡슐화 하는 접근 방법이다. 주어진 작업을 수행하기 위해 협력하는 객체들의 모임이 바로 프로그램이다. <br>
<br>
	<font style="font-weight:bold;">절차지향 프로그램</font>은 계층적인 구조<br>
	<font style="font-weight:bold;">객체지향 프로그램</font>은 클래스의 모임으로 프로그램 구문의 기초단위를 이루며 호출관계가 아닌 다른 형태의 관계로 계층을 형성한다.<br>
<br>
<h3>객체 =인스턴스</h3>
프로그램을 이루는 구문 단위의 클래스의 인스턴스로서 데이터 추상화와 프러시저 추상화를 모두 실현한 개념. 프로그램에 존재하는 구조화된 데이터의 덩어리로 <font color="#86E57F"> 상태와 행위</font>라는 요소를 가진다.<br>
<br>
<h3>클래스</h3>
데이터를 추상화 하는 단위이며 유사한 객체들을 정의한프로그램.<br>
	클래스는 일반적으로 <font color="#86E57F">속성과 메소드</font>를 가진다.<br>
인스턴스 변수를 가짐<br>
속성 –자료, 객체의 상태를 나타내는 값.<br>
메소드 –오퍼레이션<br>
<br>
<h3>클래스 변수</h3>
-클래스에 속하는 객체들이 공유하는 값.<br>
<br>
<h3>메소드</h3>
-클래스의 행위를 구현하는 프러시저(함수)<br>
<br>
<h3>오퍼레이션</h3>
-클래스 행위의 타입을 뜻함<br>
<br>
<h3>오퍼레이션의 다형성</h3>
-같은 이름의 메소드 중 어떤 것을 호출할지 결정해야 하는 대 이를 오퍼레이션의 다형성<br>
<br>
<h3>일반화</h3>
-여러 개의 서브클래스로부터 공통점을 찾아내서 슈퍼클래스로 만 듬.<br>
[EX class 고등어,낚지 ->수중[일반화] ]<br>
<br>
<h3>상속 –객체지향 패러다임의 장점</h3>
-슈퍼 클래스에 정의한 변수와 메소드를 서브클래스가 묵시적으로 소유하게 하는 것<br>
부모 클래스의 기능을 자식 클래스도 사용하여 코드의 중복을 없애는 것.<br>
is-a 관계<br>
<br>
<h3>다형성 –객체지향 패러다임의 장점</h3>
-여러 클래스의 같은 이름의 메소드가 존재할 때, 각자의 기능이 다를 때 같은 이름으로 다른 기능을 구현할 때 사용 함.<br>
속성이나 변수가 서로 다른 클래스에 속하는 객체를 지칭할 수 있는 성질이다.<br>
오퍼레이션의 이름은 같게 하는 것이 다형성의 핵심이다.<br>
다형성은 동적 바인딩으로 실현된다.<br>
<br>
<h3>함수 재정의</h3>
- 슈퍼클래스에서 정의된 메소드가 서브클래스에서 다시 정의되는 것.<br>
이름이 같고 다시 사용함.[오버라이딩]<br>
<br>
<h3>추상 클래스</h3>
-개념만 가진 클래스 ,내부 동작 구현이 없습니다.<br>
클래스의 명칭과 메소드는 있으나 메소드 기능이 없는것.<br>
기능은 상속받은 자식 클래스에서 구현.<br>
<br>
<h3>가상 함수</h3>
-오퍼레이션 정의만 하는 것[추상 클래스에서 정의한 함수] <br>
<br>
<h3>메시지</h3>
객체들 사이의 상호작용 수단이 메시지<br>
<br>
<h3>캡슐화</h3>
캡슐화는 클래스로 구현<br>
클래스 안에 기능을 넣고 기능을 분할해야 함.<br>
정보 은닉<br>
	
	<h1><p style="text-align: center">객체지향 개념</p></h1>

1.클래스는 일반적으로 □□과 □□□를 가진다.<br>
	-속성, 메소드<br>
2. □□□ □□을 프로그래밍 방법으로 표현하면, 객체 이름, 메소드 이름, 매개변수로 표현한다.<br>
	-메시지 전달<br>
3.□□이란 수퍼 클래스에 정의한 속성과 메소드를 서브클래스가 묵시적으로 소유하는 것이다.<br>
	-상속<br>
4. □□□은 여러 클래스에 같은 이름의 메소드가 존재하지만 동작은 각 클래스에서 다르게 구현할 수 있는 개념이다.<br>
	-다형성<br>
5.□□□□□□는 수퍼클래스에서 정의된 메소드가 서브클레스에서 다시 정의되는 것을 말한다.<br>
	-메소드재정의<br>
6.□□□□□는 클래스의 명칭과 메소드는 있으나 메소드의 처리 내용은 없다.<br>
	-추상클래스<br>
7.클래스는 하나의 상위 클래스로서만 상속받을 수 있지만, 인터페이스는 여러 개의 인터페이스로부터 상속받을 수 잇기 때문에 □□□□의 기능을 제공한다.<br>
	-다중상속<br>
	<br>
	<br>
1. 객체지향 프로그램이란 프러시저 □□□와 □□□ □□□로 이루어져 있다.<br>
-추상화, 데이터추상화<br>
<br>
2. □□□□ □□□□이란 데이터 및 데이터에 접근하고 수정하는 <font color="#86E57F">프러시저를 같은 범주</font 안에 두고 캡슐화 하는 접근 방법이다. 주어진 작업을 수행하기 위해 협력하는 <font color="#86E57F">객체들의 모임</font>이 바로 프로그램은 무엇인가<br>
-객체지향 패러다임<br>
	<br>
	3. □□□는 <font color="#86E57F">데이터를 추상화 하는 단위</font>이며 <font color="#86E57F">유사한 객체들을 정의한프로그램</font>으로 일반적으로 □□과 □□□를 가진다<br>
-클래스, 속성, 메소드<br>
	<br>
	4. □□는 <font color="#86E57F">프로그램을 이루는 구문 단위</font>의 클래스의 인스턴스로서 데이터 추상화와 프러시저 추상화를 모두 실현한 개념. 프로그램에 존재하는 <font color="#86E57F">구조화된 데이터의 덩어리</font>로 □□와 □□라는 요소를 가진다.<br>
-객체, 상태, 행위
	<br>
	5.□□□는 <font color="#86E57F">클래스의 행위를 구현</font>하는 프러시저이고 □□□□□은 <font color="#86E57F">클래스 행위의 타입</font>을 뜻함<br>
	-메소드, 오퍼레이션
<br>
	6.<font color="#86E57F">같은 이름의 메소드</font> 중 어떤 것을 호출할지 결정해야하는 대 이는 무엇인가, <br>
*어떤 객체에 대해 함수를 호출했느냐에 따라 메소드가 결정된다.<br> 
1.오퍼레이션의 다형성		2.오버라이딩<br>
3.함수재정의		 	   4.오버로딩<br>
	*1번<br>
<br>
	7. 여러개의 <font color="#86E57F">서브클래스로부터 공통점</font>을 찾아내서 슈퍼클래스로 만 드는 것은?<br>
	-일반화<br>
<br>
	8. □□이란 <font color="#86E57F">슈퍼 클래스에 정의한 변수와 메소드를 서브클래스가 묵시적으로 소유</font>하게 하는 것<br>
	-상속<br>
<br>
	9.<font color="#86E57F">동적 바인딩</font>으로 실행되며 <font color="#86E57F">여러 클래스의 같은 이름의 메소드</font>가 존재할 때, <font color="#86E57F">각자의 기능이 다를 때 같은 이름</font>으로 다른 기능을 구현할 때 사용 함.<br>
-다형성<br>
	<br>
	10. <font color="#86E57F">슈퍼클래스에서 정의된 메소드</font>가 <font color="#86E57F">서브클래스에서 다시 정의</font>되는 것 이름이 같고 다시 사용함<br>
-함수의 재정의<br>
	<br>
11. □□□□□란 클래스의 명칭과 메소드는 있으나 메소드 기능이 없는 것. 기능은 상속받은 자식 클래스에서 구현. □□□□란 오퍼레이션 정의만 하는 것<br>
-추상클래스, 가상함수<br>
	<br>
	12.□□□이란 객체지향 소프트웨어를 모델링 하는 표준 그래픽 언어로써 <font color="#86E57F">사용자가 무엇을 원하는지 파악하기 위해서</font>.<br>
-UML<br>
	<br>
13. 객체 사이의 메시지 교환을 시간의 흐름에 따라 나타낸 것이다. <br>
1.Use Case [사용 사례] 다이어그램 <br>
2.클래스 다이어그램 <br>
3.시퀀스 다이어그램 <br>
4.상태 다이어그램<br>
	*3번 <br>
<br>
14 모델링 절차로 옳은 것은<br>
1. 시스템 상황을 확인 –액터 식별 –유스케이스 식별 -유스케이스 다이어그램 작성 -유스케이스 명세서 작성 –유스케이스 실체화.<br>
2. 액터 식별 –유스케이스 식별 -유스케이스 다이어그램 작성 -유스케이스 명세서 작성-시스템 상황을 확인  –유스케이스 실체화.<br>
3. 액터 식별 –유스케이스 식별 -시스템 상황을 확인  -유스케이스 다이어그램 작성 -유스케이스 명세서 작성 –유스케이스 실체화.<br>
4. 액터 식별 –유스케이스 식별 -유스케이스 다이어그램 작성 -유스케이스 명세서 작성 –유스케이스 실체화-시스템 상황을 확인 .<br>
	*1번 <br>
	<br>
	15.□□□□□□의 목적은 소프트웨어 엔지니어의 아이디어에 대한 <font color="#86E57F">피드백</font>을 조기에 받아서 요구 사항을 취합하는 것이<br>
-프로토타이핑<br>
	<br>
16.소프트웨어 개발 단계를 순서대로 나열하시오<br>
설계 유지보수 테스트 요구분석 코딩  <br>
-요구분석 -설계 -코딩 -테스트 -유지보수 <br>
	 <br>
17. 설계 단계에서 사용하는 다이어그램이 아닌 것은<br>
1.유스케이스 다이어그램<br>
2.클래스 다이어 그램<br>
3.ER 다이어 그램<br>
4.순차 다이어그램<br>
5.커뮤니케이션 다이어그램<br>
	* 1번 유스케이스 다이어그램은 요구분석에서 사용하는것이다.<br>
	
<!-- 본문 끝-->
      </div><!--main-post-->
    </div><!-- main-wrapper 본문 끝-->
  </div><!-- wrapper-->

  <div id="footers"></div>

</body>

</html>
